package utils

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"math/big"
	"testing"
	"time"

	. "github.com/onsi/gomega"
)

func TestValidateCertificateKeyPair(t *testing.T) {
	g := NewWithT(t)

	t.Run("validates matching certificate and key", func(t *testing.T) {
		// Generate a test key pair
		key, err := rsa.GenerateKey(rand.Reader, 2048)
		g.Expect(err).NotTo(HaveOccurred())

		// Create a self-signed certificate
		template := &x509.Certificate{
			SerialNumber:          big.NewInt(1),
			Subject:               pkix.Name{CommonName: "test"},
			NotBefore:             time.Now(),
			NotAfter:              time.Now().AddDate(1, 0, 0),
			BasicConstraintsValid: true,
			IsCA:                  false,
			KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
			ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		}

		certDER, err := x509.CreateCertificate(rand.Reader, template, template, &key.PublicKey, key)
		g.Expect(err).NotTo(HaveOccurred())

		certPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certDER})
		keyPEM := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(key)})

		// Validation should succeed
		err = ValidateCertificateKeyPair(string(certPEM), string(keyPEM))
		g.Expect(err).NotTo(HaveOccurred())
	})

	t.Run("detects mismatched certificate and key", func(t *testing.T) {
		// Generate two different key pairs
		key1, err := rsa.GenerateKey(rand.Reader, 2048)
		g.Expect(err).NotTo(HaveOccurred())

		key2, err := rsa.GenerateKey(rand.Reader, 2048)
		g.Expect(err).NotTo(HaveOccurred())

		// Create a certificate with key1's public key
		template := &x509.Certificate{
			SerialNumber:          big.NewInt(1),
			Subject:               pkix.Name{CommonName: "test"},
			NotBefore:             time.Now(),
			NotAfter:              time.Now().AddDate(1, 0, 0),
			BasicConstraintsValid: true,
			IsCA:                  false,
			KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
			ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		}

		certDER, err := x509.CreateCertificate(rand.Reader, template, template, &key1.PublicKey, key1)
		g.Expect(err).NotTo(HaveOccurred())

		certPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certDER})
		// Use key2's private key (mismatch!)
		keyPEM := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(key2)})

		// Validation should fail
		err = ValidateCertificateKeyPair(string(certPEM), string(keyPEM))
		g.Expect(err).To(HaveOccurred())
		g.Expect(err.Error()).To(ContainSubstring("modulus does not match"))
	})

	t.Run("validates certificate and key generated by SignCertificate", func(t *testing.T) {
		template, err := GenerateCertificate(
			pkix.Name{CommonName: "test"},
			time.Now(),
			time.Now().AddDate(1, 0, 0),
			false,
			[]string{"test.example.com"},
			nil,
		)
		g.Expect(err).NotTo(HaveOccurred())

		// Create a CA for signing
		caTemplate, err := GenerateCertificate(
			pkix.Name{CommonName: "ca"},
			time.Now(),
			time.Now().AddDate(10, 0, 0),
			true,
			nil,
			nil,
		)
		g.Expect(err).NotTo(HaveOccurred())

		caCert, caKey, err := SignCertificate(caTemplate, 2048, caTemplate, nil, nil)
		g.Expect(err).NotTo(HaveOccurred())

		// Parse CA for signing
		caCertParsed, caKeyParsed, err := LoadCertificate(caCert, caKey)
		g.Expect(err).NotTo(HaveOccurred())

		// Sign certificate with CA
		certPEM, keyPEM, err := SignCertificate(template, 2048, caCertParsed, &caKeyParsed.PublicKey, caKeyParsed)
		g.Expect(err).NotTo(HaveOccurred())

		// Validation should succeed (SignCertificate already validates, but test it explicitly)
		err = ValidateCertificateKeyPair(certPEM, keyPEM)
		g.Expect(err).NotTo(HaveOccurred())
	})
}
